{"version":3,"file":"naive.js","sources":["../../src/utils.js","../../src/dom.js","../../src/vdom/vtext.js","../../src/vdom/vnode.js","../../src/vdom/utils.js","../../src/vdom/patch.js","../../src/vdom/list-diff.js","../../src/vdom/diff.js","../../src/vdom/h.js","../../src/cache.js","../../src/parser.js","../../src/api/hooks.js","../../src/exception.js","../../src/main.js"],"sourcesContent":["export function warn (message) {\n  if (window.console) {\n    console.warn(`[naive.js] ${message}`);\n  }\n}\n\nexport function error (message) {\n  if (window.console) {\n    console.error(`[naive.js] ${message}`);\n  }\n}\n\nexport const isArray = Array.isArray ? Array.isArray : function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nexport function isUndefined (obj) {\n  return typeof obj === 'undefined';\n}\n\nexport function noop () {}\n\nexport function extend(obj, props) {\n  if (props) {\n    for (let i in props) obj[i] = props[i];\n  }\n  return obj;\n}\n\nexport function clone(obj) {\n  return extend({}, obj);\n}\n\nexport function isFunction (obj) {\n  return typeof obj === 'function';\n}\n\nexport function isPlainObject (obj) {\n  return obj != null && typeof obj === 'object' && !isArray(obj) && Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nlet resolved = typeof Promise!=='undefined' && Promise.resolve();\nexport const defer = resolved ? (f => { resolved.then(f); }) : setTimeout; // asap async\n","import { isUndefined } from './utils';\n\n/**\n * 获取元素\n *\n * IE 8 只支持到 CSS2 选择器\n *\n * @param {String} selector\n */\nexport function getElement(selector) {\n  return typeof selector === 'string' ? query(selector) : selector;\n}\n\nexport function createElement(tag) {\n  return document.createElement(tag);\n}\n\nexport function createTextNode (text) {\n  return document.createTextNode(text);\n}\n\nexport function createDocumentFragment () {\n  return document.createDocumentFragment();\n}\n\nexport function query(selector, context) {\n  context = context || document;\n  return context.querySelector(selector);\n}\n\n/**\n * 检查一个元素是否在 document 内\n */\nexport function inDoc(node) {\n  var doc = node.ownerDocument.documentElement;\n  return doc === node || node && node.nodeType === 1 && doc.contains(node);\n}\n\nexport function removeNode(node) {\n  node.parentNode.removeChild(node)\n}\n\nexport function createAnchor(name) {\n  var n = document.createTextNode('');\n  n.name = name;\n  return n;\n}\n\nexport function before(newNode, node) {\n  node.parentNode.insertBefore(newNode, node);\n}\n\nexport function replaceNode(newNode, node) {\n  node.parentNode.replaceChild(newNode, node);\n}\n\nexport function after(el, target) {\n  if (target.nextSibling) {\n    before(el, target.nextSibling)\n  } else {\n    target.parentNode.appendChild(el)\n  }\n}\n\nexport function appendChild (el, target) {\n  target.appendChild(el);\n}\n\nexport function setAttr (node, attr, value) {\n  node.setAttribute(attr, value);\n}\n\nexport function hasAttr(node, name) {\n  return node.hasAttribute(name);\n}\n\nexport function removeAttr(node, name) {\n  node.removeAttribute(name);\n}\n\nexport function removeAllChildren(node) {\n  while(node.childNodes.length > 0) {\n    node.removeChild(node.childNodes[0]);\n  }\n}\n\n\nconst classSplitReg = /\\s+/;\n\nconst supportClassList = !isUndefined(document.createElement('div').classList);\n\nlet getClasses = supportClassList ?\n  function(element) {\n    return Array.prototype.slice.call(element.classList);\n  }\n  :\n  function(element) {\n    return element.className.split(/\\s+/).filter(s => s);\n  };\n\nexport let hasClass = supportClassList ?\n  function(element, classes) {\n    classes = classes.split(/\\s+/).filter(s => s);\n    var contains = true;\n    for (let i = 0; i < classes.length; ++i) {\n      if (!element.classList.contains(classes[i])) {\n        contains = false;\n        break;\n      }\n    }\n    return contains;\n  }\n  :\n  function(element, classes) {\n    classes = classes.split(/\\s+/).filter(s => s);\n    var contains = true, tmp = element.className;\n    for (let i = 0; i < classes.length; ++i) {\n      if (tmp.indexOf(classes[i]) === -1) {\n        contains = false;\n        break;\n      }\n    }\n    return contains;\n  };\n\nexport let addClass = supportClassList ?\n  function(element, classes) {\n    classes = classes.split(/\\s+/).filter(s => s);\n    element.classList.add.apply(element.classList, classes);\n    return element;\n  }\n  :\n  function(element, classes) {\n    var tmp = element.className;\n    classes = classes.split(/\\s+/).filter(s => s);\n    classes.forEach(c => {\n      if (!hasClass(element, c)) {\n        tmp = tmp.replace(/\\s+|$/, ' ' + classes);\n      }\n    });\n    element.className = tmp;\n    return element;\n  };\n\nexport let removeClass = supportClassList ?\n  function(element, classes) {\n    classes = classes.split(/\\s+/).filter(s => s);\n    element.classList.remove.apply(element.classList, classes);\n    return element;\n  }\n  :\n  function(element, classes) {\n    var tmp = element.className;\n    classes = classes.split(/\\s+/).filter(s => s);\n    classes.forEach(c => {\n      if (hasClass(element, c)) {\n        tmp = tmp.replace(new RegExp(c, 'g'), '');\n      }\n    });\n    element.className = tmp;\n    return element;\n  };\n\nexport let toggleClass = supportClassList ?\n  function(element, classes, force) {\n    classes = classes.split(/\\s+/).filter(s => s);\n    classes.forEach(c => {\n      element.classList.toggle(c, force);\n    });\n    return element;\n  }\n  :\n  function(element, classes, force) {\n    classes = classes.split(/\\s+/).filter(s => s);\n    var useForce = force !== undefined;\n    classes.forEach(c => {\n      if (hasClass(element, c) && (useForce && !force || !useForce)) {\n        removeClass(element, c);\n      } else if (!hasClass(element, c) && (useForce && force || !useForce)) {\n        addClass(element, c);\n      }\n    });\n    return element;\n  };\n","import { createTextNode } from '../dom';\n\n// virtual text node\nexport default function VText (text) {\n  this.data = text;\n}\n\nVText.prototype.render = function vdom2dom () {\n  return createTextNode(this.data);\n};\n","import { createElement, setAttr, appendChild } from '../dom';\nimport VText from './vtext';\nimport { isVNode, isVText } from './utils';\nimport { isArray, isFunction } from '../utils';\n\nexport default function VNode (tagName, props, children, key) {\n  this.tagName = tagName;\n  this.props = props || {};\n  this.key = key ? String(key) : undefined; // key 用来标识节点，方便 diff\n  let childNodes = [];\n  children = children || [];\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    if (isVNode(child) || isVText(child)) {\n      childNodes.push(child);\n    } else if (typeof child === 'string') {\n      childNodes.push(new VText(child));\n    } else if (isArray(child)) {\n      childNodes = childNodes.concat(child);\n    } else {\n      // ignore\n    }\n  }\n  this.children = childNodes;\n  let count = this.children.length;\n  for (let i = 0; i < this.children.length; ++i) {\n    count += this.children[i].count || 0;\n  }\n  this.count = count; // 记录子节点数，方便 patch 的时候找到节点位置\n}\n\n// 检查是否指令属性\nfunction checkAttrDirective (attr) {\n  return /^@|n-|:/.test(attr);\n}\n\n// add event listener\nfunction isEventDirective (attr) {\n  return /^@/.test(attr);\n}\n\nfunction attachEvent (el, eventName, handler) {\n  if (el.addEventListener) {\n    el.addEventListener(eventName, handler, false);\n  } else if (el.attachEvent) {\n    el.attachEvent(eventName, handler);\n  } else {\n    el[`on${eventName}`] = handler;\n  }\n}\n\nfunction detachEvent () {}\n\nVNode.prototype.render = function vdom2dom(context) {\n  const el = createElement(this.tagName);\n  const props = this.props;\n  for (let p in props) {\n    if (checkAttrDirective(p)) {\n      if (isEventDirective(p)) {\n        const eventName = p.slice(1);\n        const handlerFunc = isFunction(props[p]) ? props[p] : context[props[p]];\n        attachEvent(el, eventName, function handler(evt) {\n          handlerFunc.call(context, evt);\n        });\n      } else {\n        // 处理指令\n      }\n    } else {\n      setAttr(el, p, props[p]);\n    }\n  }\n  for (let i = 0; i < this.children.length; ++i) {\n    appendChild(this.children[i].render(context), el);\n  }\n  return el;\n};\n","import VText from './vtext';\nimport VNode from './vnode';\n\nexport function isVNode (node) {\n  return node instanceof VNode;\n}\n\nexport function isVText (node) {\n  return node instanceof VText;\n}\n","import { setAttr, replaceNode, removeNode } from '../dom';\n\nexport const PATCH = {\n  REPLACE: 0, // 替换节点\n  INSERT: 1, // 插入\n  REMOVE: 2, // 移除\n  REORDER: 3, // 重排\n  PROPS: 4, // 修改属性\n  TEXT: 5 // 替换文本\n};\n\n// @TODO patch 的 index 不对？\nexport function patch (context, domNode, patches) {\n  const walker = {index: 0};\n  dfsWalk(context, domNode, walker, patches);\n}\n\nfunction dfsWalk (context, domNode, walker, patches) {\n  const currentPatches = patches[walker.index];\n\n  const len = domNode.childNodes ? domNode.childNodes.length : 0;\n  for (let i = 0; i < len; i++) {\n    const child = domNode.childNodes[i];\n    walker.index++;\n    dfsWalk(context, child, walker, patches);\n  }\n  if (currentPatches) {\n    applyPatches(context, domNode, currentPatches);\n  }\n}\n\nfunction patchReorder (context, domNode, moves) {\n  for (let i = 0; i < moves.length; ++i) {\n    const move = moves[i];\n    switch (move.type) {\n      case PATCH.INSERT: // 插入新节点\n        const target = domNode.childNodes[move.index] || null; // null 插入末尾\n        domNode.insertBefore(move.item.render(context), target);\n        break;\n      case PATCH.REMOVE:\n        removeNode(domNode.childNodes[move.index]);\n        break;\n      default:\n        // error type\n    }\n  }\n}\n\n// 检查是否指令属性\nfunction isAttrDirective (attr) {\n  return /^@|n-|:/.test(attr);\n}\n// 检查是否事件指令\nfunction isEventDirective (attr) {\n  return /^@/.test(attr);\n}\n\nfunction patchProps (domNode, patch) {\n  for (let p in patch.props) {\n    if (patch.props.hasOwnProperty(p)) {\n      // 检查是否指令属性\n      if (isAttrDirective(p)) {\n        if (isEventDirective(p)) {\n          // removeEventListener\n          // addEventListener\n        } else { // 其他指令属性\n        }\n      } else { // 普通属性\n        setAttr(domNode, p, patch.props[p]);\n      }\n    }\n  }\n}\n\n// 根据补丁更新 DOM 节点\nfunction applyPatches (context, domNode, patches) {\n  for (let i = 0; i < patches.length; ++i) {\n    const patch = patches[i];\n    switch (patch.type) {\n      case PATCH.REPLACE: // 替换元素节点\n        replaceNode(patch.node.render(context), domNode);\n        break;\n      case PATCH.PROPS: // 属性修改\n        patchProps(domNode, patch);\n        break;\n      case PATCH.TEXT: // 替换文本内容\n        domNode.data = patch.data;\n        break;\n      case PATCH.REORDER: // 子节点重新排序\n        patchReorder(context, domNode, patch.moves);\n        break;\n      default:\n        // warn\n    }\n  }\n}\n","import { PATCH } from './patch'; //REORDER_INSERT\n\n// 分别找到有 key 的元素位置和没有 key 的元素的位置\nfunction makeKeyIndexAndFree (list) {\n  const keyIndex = {}; // 有 key 的节点位置\n  const free = []; // 可替换的位置（没有 key 的节点都被标识为可替换的节点）\n  for (let i = 0, len = list.length; i < len; i++) {\n    const item = list[i]\n    const itemKey = item.key;\n    if (itemKey) {\n      keyIndex[itemKey] = i;\n    } else {\n      free.push(item);\n    }\n  }\n  return {\n    keyIndex: keyIndex,\n    free: free\n  };\n}\n\nexport default function listDiff (pList, nList) {\n  const nMap = makeKeyIndexAndFree(nList);\n  const nKeys = nMap.keyIndex, nFree = nMap.free;\n  const pMap = makeKeyIndexAndFree(pList);\n  const pKeys = pMap.keyIndex, pFree = pMap.free;\n  // 先处理有 key 的元素，看其在 nList 还是否存在，如果不存在说明被移除\n  const children = [];\n  for (let i = 0, freeIndex = 0; i < pList.length; ++i) {\n    const item = pList[i];\n    const itemKey = item.key;\n    if (itemKey) {\n      if (!nKeys.hasOwnProperty(itemKey)) {\n        children.push(null);\n      } else {\n        const itemKeyIndex = nKeys[itemKey];\n        children.push(nList[itemKeyIndex]);\n      }\n    } else {\n      children.push(nFree[freeIndex++] || null);\n    }\n  }\n  const moves = [];\n  function remove (index) {\n    moves.push({\n      type: PATCH.REMOVE,\n      index: index\n    });\n  }\n  function insert (index, item) {\n    moves.push({\n      type: PATCH.INSERT,\n      index: index,\n      item: item\n    });\n  }\n  const simulateList = children.slice(0);\n  // 找出被移除的节点\n  let i = 0;\n  while (i < simulateList.length) {\n    if (simulateList[i] === null) {\n      remove(i);\n      simulateList.splice(i, 1);\n    } else {\n      ++i;\n    }\n  }\n  // 遍历 nList\n  for (let s = 0, n = 0; n < nList.length; ++n) {\n    const nItem = nList[n];\n    const nItemKey = nItem.key;\n    const sItem = simulateList[s];\n    if (sItem) {\n      const sItemKey = sItem.key;\n      if (sItemKey === nItemKey) { // 相同元素相同位置\n        s++;\n      } else {\n        if (!pKeys.hasOwnProperty(nItemKey)) { // 旧列表中不存在，新节点\n          insert(n, nItem); // 在位置 n 插入新节点 nItem\n        } else { // 旧列表中存在，需要移位（移位操作包括删除和插入两者中的一个或两个）\n          const nsItemKey = simulateList[s + 1].key;\n          if (nsItemKey === nItemKey) {\n            remove(n);\n            simulateList.splice(s, 1);\n            s++;\n          } else {\n            insert(n, nItem);\n          }\n        }\n      }\n    } else { // 旧列表该位置为空，直接插入\n      insert(n, nItem);\n    }\n  }\n  return {\n    moves: moves,\n    children: children\n  };\n}\n","import { isVNode, isVText } from './utils';\nimport listDiff from './list-diff';\nimport { PATCH } from './patch';\nimport { isArray } from '../utils';\n\n// diff two vdom node\nexport function diff (oldTree, newTree) {\n  let index = 0;\n  let patches = {};\n  if (isArray(oldTree)) {\n    const currentPatches = [];\n    diffChildren(oldTree, newTree, 0, patches, currentPatches);\n    if (currentPatches.length) {\n      patches[0] = currentPatches;\n    }\n  } else {\n    diffWalk(oldTree, newTree, index, patches);\n  }\n  return patches;\n}\n\nfunction diffWalk (pNode, nNode, index, patches) {\n  let currentPatches = []; // 当前层级的 patch\n  if (nNode === null) {\n    // 这种情况属于：在 diffChildren 的时候该节点被标识为被删除的节点，但是不需要在这里删除（在 reorder 的时候会处理删除）\n  } else if (isVNode(pNode) && isVNode(nNode)) { // 都是 VNode\n    if (pNode.tagName !== nNode.tagName || pNode.key !== nNode.key) { // 不同节点，或者已标识不是同一节点，要替换\n      currentPatches.push({type: PATCH.REPLACE, node: nNode});\n    } else {\n      let propsPatches = diffProps(pNode, nNode);\n      if (propsPatches) {\n        currentPatches.push({type: PATCH.PROPS, props: propsPatches});\n      }\n      // 继续 diff 子节点\n      diffChildren(pNode.children, nNode.children, index, patches, currentPatches);\n    }\n  } else if (isVText(pNode) && isVText(nNode)) { // 都是 VText\n    if (pNode.data !== nNode.data) { // 内容不一样的时候才替换（只替换内容即可）\n      currentPatches.push({type: PATCH.TEXT, data: nNode.data});\n    }\n  } else { // 类型不一样，绝对要替换\n    currentPatches.push({type: PATCH.REPLACE, node: nNode});\n  }\n  if (currentPatches.length) {\n    patches[index] = currentPatches;\n  }\n}\n\nfunction diffProps (oldTree, newTree) {\n  let oldTreeProps = oldTree.props;\n  let newTreeProps = newTree.props;\n  let propsPatches = {}, count = 0;\n  for (let p in oldTreeProps) {\n    if (!newTreeProps.hasOwnProperty(p) || newTreeProps[p] !== oldTreeProps[p]) {\n      propsPatches[p] = newTreeProps[p];\n      count += 1;\n    }\n  }\n  if (count <= 0) {\n    return null;\n  }\n  return propsPatches;\n}\n\nfunction diffChildren (pChildNodes, nChildNodes, index, patches, currentPatches) {\n  const diffs = listDiff(pChildNodes, nChildNodes, index, patches);\n  const newChildren = diffs.children;\n\n  if (diffs.moves.length) { // 需要 reorder\n    // reorder 的操作在父节点执行，所以应该加到父节点的 patch\n    const reorderPatch = { type: PATCH.REORDER, moves: diffs.moves };\n    currentPatches.push(reorderPatch);\n  }\n  \n  // 除了重排的 patch 还有各个子节点自身的 patch\n  let leftNode = null;\n  let currentNodeIndex = index;\n  for (let i = 0; i < pChildNodes.length; ++i) {\n    currentNodeIndex = (leftNode && leftNode.count)\n      ? currentNodeIndex + leftNode.count + 1\n      : currentNodeIndex + 1\n    diffWalk(pChildNodes[i], newChildren[i], currentNodeIndex, patches);\n    leftNode = pChildNodes[i];\n  }\n}\n","import VNode from './vnode';\nimport VText from './vtext';\nimport { isArray, isPlainObject } from '../utils';\nimport { isVNode, isVText } from './utils';\n\nexport default function h (tagName, props, children, key) {\n  if (isVNode(tagName) || isVText(tagName)) {\n    return tagName;\n  } else if (isPlainObject(tagName)) {\n    return new VNode(tagName.tagName, tagName.attrs, tagName.children, tagName.key);\n  } else if (isArray(tagName)) {\n    const list = [];\n    for (let i = 0; i < tagName.length; ++i) {\n      list.push(h(tagName[i]));\n    }\n    return list;\n  } else if(arguments.length < 2) {\n    return new VText(tagName);\n  } else {\n    return new VNode(tagName, props, children, key);\n  }\n}\n","/**\n * 双向链表实现的使用 LRU 算法的缓存\n * 缓存最近最常用的项目，当缓存满时丢弃最近最少用的项目\n *\n * @param {Number} 缓存最大限制\n * @constructor\n */\n\nexport default function Cache (limit) {\n  this.size = 0; // 缓存大小\n  this.limit = limit; // 缓存大小最大限制\n  this.head = this.tail = undefined; // 头尾指针\n  this._keymap = Object.create(null); // 缓存映射表\n}\n\nvar p = Cache.prototype;\n\n/**\n * 将 <key> <value> 键值对存储到缓存映射表\n * 如果缓存满了，删除一个节点让出空间给新的缓存，并返回被删的节点\n * 否则返回 undefined\n *\n * @param {String} 键\n * @param {*} 值\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var removed;\n\n  var entry = this.get(key, true); // 先查看是否已经有缓存，如果有，只需要更新它的 value 就可以了\n  if (!entry) {\n    if (this.size === this.limit) { // 缓存满了\n      removed = this.shift();\n    }\n    entry = {\n      key: key\n    };\n    this._keymap[key] = entry;\n    if (this.tail) {\n      this.tail.newer = entry;\n      entry.older = this.tail;\n    } else {\n      this.head = entry;\n    }\n    this.tail = entry; // 将这个项目作为最新的插入缓存\n    this.size++;\n  }\n  entry.value = value;\n\n  return removed;\n}\n\n/**\n * 从缓存中清除最近最少使用（放得最久的）项目\n * 返回被清除的项目，如果缓存为空就返回 undefined\n */\n\np.shift = function () {\n  var entry = this.head;\n  if (entry) {\n    this.head = this.head.newer; // 头部的是最旧的，所以要从头部开始清除\n    this.head.older = undefined;\n    entry.newer = entry.older = undefined;\n    this._keymap[entry.key] = undefined;\n    this.size--;\n  }\n  return entry;\n}\n\n/**\n * 获取并且注册最近使用的 <key>\n * 返回 <key> 对应的值\n * 如果缓存中找不到这个 <key> 就返回 undefined\n *\n * @param {String} 键\n * @param {Boolean} 是否返回整个 entry ，如果为 false 则只返回 value\n * @return {Entry|*} 返回 Entry 或者它的值，或者 undefined\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key];\n  if (entry === undefined) return; // 缓存不存在，直接返回 undefined\n  if (entry === this.tail) { // 缓存是最新的，直接返回这个缓存项（或者它的值）\n    return returnEntry\n      ? entry\n      : entry.value;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) { // 如果缓存不是最新的\n    if (entry === this.head) { // 如果缓存是最旧的\n      this.head = entry.newer; // 将比它新的作为最旧的\n    }\n    entry.newer.older = entry.older; // C <-- E. 将它的后一个作为前一个的最旧\n  }\n  if (entry.older) { // 如果有比它更旧的\n    entry.older.newer = entry.newer; // C. --> E 将它的前一个作为后一个的最新\n  }\n  entry.newer = undefined; // D --x // 它本身没有更新的\n  entry.older = this.tail; // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry; // E. <-- D\n  }\n  this.tail = entry; // 将自己作为最新的\n  return returnEntry\n    ? entry\n    : entry.value;\n}\n","import Cache from './cache';\nimport { isUndefined } from './utils';\n\nconst pathCache = new Cache(1000);\n\nconst TrimRE = /^\\s+|\\s$/g;\nconst WordsRE = /([a-zA-Z$][\\w.$]*)/g;\n\n// 一个别名对应一个作用域\nfunction parseExpressionFor(exp, scope) {\n  var vars = exp.split(/\\s+in\\s+/);\n  var alias = vars[0], expression = vars[1];\n  return {\n    alias: alias,\n    raw: expression,\n    scope: expression,\n    expression: parseExpressionGetter(expression, scope)\n  };\n}\n\nexport function splitPath(expression) {\n  expression = expression.replace(/^\\s+|\\s$/g, ''); // trim\n  var wordsRE = /([a-zA-Z$][\\w.$]*)/g;\n  return expression.match(wordsRE) || [];\n}\n\nconst saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\")/g;\nconst restoreRE = /\"(\\d+)\"/g;\nconst wsRE = /\\s/g;\nconst newlineRE = /\\n/g;\nconst identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\n\nvar saved = [];\n\nfunction save (str, isString) {\n  var i = saved.length\n  saved[i] = isString\n    ? str.replace(newlineRE, '\\\\n')\n    : str\n  return '\"' + i + '\"'\n}\n\nfunction rewrite (raw, scope) {\n  var c = raw.charAt(0);\n  var path = raw.slice(1);\n  path = path.indexOf('\"') > -1\n    ? path.replace(restoreRE, restore)\n    : path;\n  var scopeVarKey = '';\n  for (let i = scope.length - 1; i >= 0; --i) { // 从后往前\n    var _scope = scope[i];\n    var namePaths = parsePath(path);\n    if (namePaths.length > 0 && namePaths[0] === _scope.alias) { // 匹配到别名，说明在当前作用域\n      namePaths = namePaths.slice(1);\n      scopeVarKey = _scope.scope + '[' + _scope.$index + ']' + (namePaths.length > 0 ? '.' + namePaths.join('.') : '');\n      break;\n    }\n  }\n  var body = 'vm.get(\"' + (scopeVarKey ? scopeVarKey : path) + '\")';\n  return c + body;\n}\n\nfunction restore (str, i) {\n  return saved[i];\n}\n\n/**\n * 解析一个表达式\n * @param {String} expression 表达式字符串\n * @param {String} scope 作用域限制\n * @return {Function} 一个函数，用来返回表达式的值\n */\nexport function parseExpressionGetter(expression, scope) {\n  saved.length = 0;\n  var parsed = expression\n    .replace(saveRE, save)\n    .replace(wsRE, '');\n  parsed = (' ' + parsed)\n    .replace(identRE, function(raw) {\n      return rewrite(raw, scope);\n    })\n    .replace(restoreRE, restore);\n  return makeGetterFunction(parsed);\n}\n\nfunction makeGetterFunction(body) {\n  return new Function('vm', 'return ' + body + ';');\n}\n\n/**\n * parseExpression 解析表达式\n * 对于 `b-for` 指令，需要特殊处理，其它指令只要返回表达式执行函数即可\n *\n * @param {String} name 指令名称\n * @param {String} expression 表达式字符串\n * @param {String} 作用域限制\n * @return {{raw:String, expression:Function}}\n */\nexport function parseExpression(name, expression, scope) {\n  if (name === 'b-for') {\n    return parseExpressionFor(expression, scope);\n  }\n  if (name === 'b-on') {\n    return {\n      raw: expression,\n      expression: expression\n    };\n  }\n  return {\n    raw: expression,\n    expression: parseExpressionGetter(expression, scope)\n  };\n}\n\n/**\n * parsePath 解析取值路径，返回真正的值，如果找不到，返回 undefined\n *\n * @param {Object} data\n * @param {String} path\n * @return {*} value\n * @throw {Error} 不合法的路径\n *\n * @example\n * parsePath('a.b.c') === ['a', 'b', 'c']\n */\nexport function parsePath(path) {\n  var hit = pathCache.get(path);\n  if (hit) {\n    return hit;\n  }\n  // data.a.b.c 👍\n  // data.a[\"b\"].c 👍\n  // data[\"a\"][\"b\"][\"c\"] 👍\n  // data.a[\"b.c\"] 👍\n  // data[\"a.b.c\"] 👍\n  // data.a[b] 👎\n  // data.a[b.c] 👎\n  var parts = path.split(/\\[|\\]/g), i = 0;\n  var props = [];\n  while (i < parts.length) {\n    var match1 = /^(\\.)?[^\\'\\\"\\.\\s]+(\\.[^\\'\\\"\\.\\s]+)*$/.test(parts[i]);\n    var match2 = /(^\\s*\\'.+\\'\\s*$)|(^\\s*\\\".+\\\"\\s*$)|(^\\s*$)/.test(parts[i]);\n    if (!(match1 || match2)) {\n      throw new Error(\"不合法的路径: \" + path);\n    }\n    if (match1) {\n      var _props = parts[i].split('.'), j = 0;\n      while(j < _props.length) {\n        if (_props[j] === '') {\n          if (i !== 0) {\n            j++;\n            continue;\n          } else {\n            throw new Error(\"不合法的路径: \" + path);\n          }\n        } else {\n          props.push(_props[j]);\n        }\n        j++;\n      }\n    } else { // match2\n      if (!/^\\s*$/.test(parts[i])) {\n        var _prop = parts[i].replace(/^\\s*[\\\"\\']|[\\'\\\"]\\s*$/g, '');\n        props.push(_prop);\n      }\n    }\n    i++;\n  }\n  pathCache.put(path, props);\n  return props;\n}\n\nexport function getObjectFromPath(data, path) {\n  var props = parsePath(path);\n  var result = props.length > 0 ? data : undefined;\n  for (let i = 0; i < props.length; ++i) {\n    result = result[props[i]];\n    if (!result) {\n      break;\n    }\n  }\n  return result;\n}\n\nexport function setObjectFromPath(data, path, value) {\n  var props = parsePath(path);\n  var current = data, parent = data;\n  for (var i = 0; i < props.length - 1; ++i) {\n    parent = current;\n    current = current[props[i]];\n    if (isUndefined(current)) {\n      current = {};\n      parent[props[i]] = current;\n    }\n  }\n  if (i >= 0) {\n    if (typeof current === 'object') {\n     current[props[i]] = value;\n    } else {\n      current = {};\n      current[props[i]] = value;\n      parent[props[i-1]] = current;\n    }\n  }\n}\n","import { isArray } from '../utils';\n\nexport function addHook (hookName, callback) {\n  let callbacks = this._hooks[hookName];\n  if (!callbacks) {\n    callbacks = [];\n  }\n  if (isArray(callback)) {\n    callbacks = callbacks.concat(callback);\n  } else {\n    callbacks.push(callback);\n  }\n  this._hooks[hookName] = callbacks;\n}\n\nexport function removeHook (hookName, callback) {\n  const callbacks = this._hooks[hookName];\n  if (!callbacks || callbacks.length === 0) {\n    return this;\n  }\n  if (!callback) {\n    callbacks.splice(0, callbacks.length);\n  } else {\n    for (let i = 0; i < callbacks.length; ++i) {\n      if (callbacks[i] === callback) {\n        callbacks.splice(i, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\nexport function callHooks (hookName) {\n  const _callbacks = this._hooks[hookName] || [];\n  for (let i = 0; i < _callbacks.length; ++i) {\n    _callbacks[i].call(this);\n  }\n}\n","export function NaiveException (message) {\n  this.name = 'NaiveException';\n  this.message = message;\n}\n","import { getElement, createElement, removeNode, createTextNode, createDocumentFragment, appendChild, replaceNode } from './dom';\nimport { diff, patch } from './vdom/vdom';\nimport h from './vdom/h';\nimport { isArray, warn, error, extend, clone, noop, isFunction, isPlainObject } from './utils';\nimport { parseExpression } from './parser';\nimport { addHook, removeHook, callHooks } from './api/hooks';\nimport { NaiveException } from './exception';\n\nconst templateHelpers = {\n  \"if\": function (condition, options) {\n    return condition ? h(options) : condition;\n  },\n  \"each\": function (list, createItem) {\n    const nodes = [];\n    for (let i = 0; i < list.length; ++i) {\n      nodes.push(h(createItem(list[i], i)));\n    }\n    return nodes;\n  }\n};\n\nexport default function Naive (options) {\n  options = options || {};\n  this._hooks = {};\n  if (!isFunction(options.state)) {\n    // 必须是 function\n    throw new NaiveException('state 必须是 Function');\n  }\n  const _state = options.state();\n  if (isPlainObject(_state)) {\n    this.state = _state;\n  } else {\n    warn('state 必须是 plain object');\n    this.state = {};\n  }\n  this.render = function render () {\n    return options.render.call(this, h, templateHelpers);\n  };\n  this.ele = null;\n  this._init(options);\n}\n\n// Naive.createVElement = h;\n\nconst prtt = Naive.prototype;\n\nprtt.setState = function setState (state) {\n  extend(this.state, state);\n  this.update();\n  return this;\n};\n\n// 更新视图\nprtt.update = function update () {\n  if (!this.mounted) { // 如果组件没有挂载到元素上，不需要更新视图\n    return this;\n  }\n  const preVdom = this.vdom;\n  this.vdom = this.render();\n  // console.log(preVdom, this.vdom);\n  const patches = diff(preVdom, this.vdom);\n  console.log(patches);\n  if (patches) {\n    patch(this, this.ele, patches);\n  } else {\n    warn('不需要更新视图');\n  }\n};\n\nprtt._init = function _init (options) {\n  const methods = options.methods || {};\n  // 将 methods 移到 this\n  for (let m in methods) {\n    if (methods.hasOwnProperty(m)) {\n      if (this.hasOwnProperty(m)) {\n        warn(`属性 \"${m}\" 已存在`);\n      } else {\n        this[m] = methods[m];\n      }\n    }\n  }\n  const hooks = options.hooks || {};\n  for (let p in hooks) {\n    if (hooks.hasOwnProperty(p)) {\n      this._addHook(p, hooks[p]);\n    }\n  }\n  this.vdom = this.render();\n};\n\nprtt.mount = function mount (selector) {\n  const mountPoint = getElement(selector);\n  if (!mountPoint) {\n    throw new NaiveException('找不到挂载节点');\n  }\n  const vdom = this.vdom;\n  if (vdom.length) { // fragment\n    const docFragment = createDocumentFragment();\n    const simFragment = { childNodes: [] };\n    for (let i = 0; i < vdom.length; ++i) {\n      const node = vdom[i].render(this);\n      simFragment.childNodes.push(node);\n      appendChild(node, docFragment);\n    }\n    this.ele = simFragment;\n    replaceNode(docFragment, mountPoint);\n  } else {\n    this.ele = vdom.render(this);\n    replaceNode(this.ele, mountPoint);\n  }\n  this.mounted = true;\n  this._callHooks('mounted');\n};\n\nprtt._callHooks = callHooks;\n\nprtt._addHook = addHook;\n\nprtt._removeHook = removeHook;\n\n// 销毁组件\nprtt.destroy = function destroy () {\n  // 销毁事件监听\n  // 调用 destroy 勾子\n  this._callHooks('destroy');\n  // 销毁勾子回调\n  for (let p in this._hooks) {\n    if (this._hooks.hasOwnProperty(p)) {\n      this._removeHook(p);\n    }\n  }\n};\n"],"names":["warn","message","window","console","isArray","Array","obj","Object","prototype","toString","call","extend","props","i","isFunction","isPlainObject","getElement","selector","query","createElement","tag","document","createTextNode","text","createDocumentFragment","context","querySelector","removeNode","node","parentNode","removeChild","replaceNode","newNode","replaceChild","appendChild","el","target","setAttr","attr","value","setAttribute","VText","data","render","vdom2dom","VNode","tagName","children","key","String","undefined","childNodes","length","child","isVNode","isVText","push","concat","count","checkAttrDirective","test","isEventDirective","attachEvent","eventName","handler","addEventListener","p","slice","handlerFunc","evt","PATCH","patch","domNode","patches","walker","index","dfsWalk","currentPatches","len","patchReorder","moves","move","type","INSERT","insertBefore","item","REMOVE","isAttrDirective","patchProps","hasOwnProperty","applyPatches","REPLACE","PROPS","TEXT","REORDER","makeKeyIndexAndFree","list","keyIndex","free","itemKey","listDiff","pList","nList","nMap","nKeys","nFree","pMap","pKeys","pFree","freeIndex","itemKeyIndex","remove","insert","simulateList","splice","s","n","nItem","nItemKey","sItem","sItemKey","nsItemKey","diff","oldTree","newTree","diffWalk","pNode","nNode","propsPatches","diffProps","oldTreeProps","newTreeProps","diffChildren","pChildNodes","nChildNodes","diffs","newChildren","reorderPatch","leftNode","currentNodeIndex","h","attrs","arguments","Cache","limit","size","head","tail","_keymap","create","put","removed","entry","get","shift","newer","older","returnEntry","pathCache","restoreRE","saved","restore","str","parsePath","path","hit","parts","split","match1","match2","Error","_props","j","_prop","replace","addHook","hookName","callback","callbacks","_hooks","removeHook","callHooks","_callbacks","NaiveException","name","templateHelpers","condition","options","createItem","nodes","Naive","state","_state","ele","_init","prtt","setState","update","mounted","preVdom","vdom","log","methods","m","hooks","_addHook","mount","mountPoint","docFragment","simFragment","_callHooks","_removeHook","destroy"],"mappings":"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"}